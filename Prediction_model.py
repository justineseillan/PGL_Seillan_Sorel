# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15OFIt4Z8-_WRl9TTNZMQXAthGNYE5ZDT
"""

import pandas as pd
import os
import numpy as np
from datetime import datetime as dt
from datetime import timedelta
import json
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Charger le fichier JSON
with open('Histo_Exchange_Rate.json') as f:
    data = json.load(f)

# Extraire les données de taux de change
batch_list = data['batchList']

# Créer une liste pour stocker les résultats
all_data = []

# Boucle à travers chaque lot de données
for batch in batch_list:
    start_time = batch['startTime']
    interval = batch['interval']
    rates = batch['rates']

    # Vérifions la taille des données
    print(f"Lot de données : {len(rates)} valeurs, Intervalle : {interval} ms")

    # Créer une série temporelle à partir des taux
    times = [dt.utcfromtimestamp(start_time / 1000 + i * interval / 1000) for i in range(len(rates))]

    # Ajouter les données dans le tableau
    all_data.extend(list(zip(times, rates)))

# Créer un DataFrame
df = pd.DataFrame(all_data, columns=['Date', 'Rate'])
df['Rate'] = pd.to_numeric(df['Rate'], errors='coerce')

# Vérifier combien de lignes ont été chargées
print(f"Nombre total de données chargées : {len(df)}")

# Supprimer les valeurs aberrantes en utilisant l'écart interquartile (IQR)
Q1 = df['Rate'].quantile(0.25)
Q3 = df['Rate'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filtrer les valeurs aberrantes
df_filtered = df[(df['Rate'] >= 9) & (df['Rate'] <= 17)]
df = df_filtered
# Vérifier combien de valeurs ont été supprimées
print(f"Nombre de valeurs supprimées (valeurs aberrantes) : {len(df) - len(df_filtered)}")

# Créer un graphique interactif avec Plotly
fig = go.Figure()

fig.add_trace(go.Scatter(x=df_filtered['Date'], y=df_filtered['Rate'],
                         mode='lines',
                         name='Taux de change SEK',
                         line=dict(color='royalblue', width=2),
                         hovertemplate='Date: %{x}<br>Taux: %{y}<extra></extra>'))

# Ajouter un titre et des labels
fig.update_layout(
    title='Évolution du taux de change SEK dans le temps',
    xaxis_title='Date',
    yaxis_title='Taux de change',
    template='plotly_dark',
    hovermode='x unified',
    margin=dict(l=50, r=50, t=80, b=80)
)

# Afficher le graphique
fig.show()

from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt

# Convertir le Timestamp en datetime et définir l'index
df['Date'] = pd.to_datetime(df['Date'])
df.set_index('Date', inplace=True)

# Définir le modèle ARIMA
model = ARIMA(df['Rate'], order=(5, 1, 0))

# Ajuster le modèle
model_fit = model.fit()

# Prévisions (pour 3 jours à venir)
forecast_steps = 3
forecast = model_fit.forecast(steps=forecast_steps)

# Mettre à jour les timestamps pour les prévisions
forecast_dates = pd.date_range(df.index[-1], periods=forecast_steps + 1, freq='D')[1:]

# Créer un graphique Plotly
fig = go.Figure()

# Ajouter les données historiques
fig.add_trace(go.Scatter(x=df.index, y=df['Rate'], mode='lines', name='Historical Data'))

# Ajouter les prévisions
fig.add_trace(go.Scatter(x=forecast_dates, y=forecast, mode='lines+markers', name='Forecast', line=dict(color='orange')))

# Ajouter des titres et étiquettes
fig.update_layout(
    title="Exchange Rate Forecast for the Next 3 Days",
    xaxis_title="Date",
    yaxis_title="Exchange Rate",
    template="plotly_dark"
)

# Afficher le graphique
fig.show()

# Afficher les prévisions
print(f"Prévisions pour les 3 prochains jours: {forecast}")

import joblib

# Entraînement du modèle
model = ARIMA(df['Rate'], order=(5, 1, 0))
model_fit = model.fit()

# Sauvegarde du modèle entraîné
joblib.dump(model_fit, 'arima_gbp_sek_model.pkl')
print("Modèle ARIMA sauvegardé sous 'arima_gbp_sek_model.pkl'")
